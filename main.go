package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// Extension is the required file extension for processed files.
const Extension = ".tmpl"

func main() {

	t := &Tmpl{}

	if err := t.Process(os.Args[1:]); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(2)
	}

	if err := t.Compile(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}

}

type Tmpl struct {
	// Files to be processed.
	Paths []string
	// Data to be applied to the files during generation.
	Data interface{}
}

// Process parses the command line flags from args.
func (t *Tmpl) Process(args []string) (err error) {

	flg := flag.NewFlagSet("tmpl", flag.ContinueOnError)
	data := flg.String("data", "", "Provide template data using json")
	file := flg.String("file", "", "Provide template data using a file path")
	flg.SetOutput(os.Stderr)

	// Parse the command line arguments.
	if err = flg.Parse(args); err != nil {
		return err
	}

	if *data != "" {
		if err = json.Unmarshal([]byte(*data), &t.Data); err != nil {
			return fmt.Errorf("Problem parsing data %s", *data)
		}
	}

	if *file != "" {
		var buf []byte
		if buf, err = ioutil.ReadFile(*file); err != nil {
			return fmt.Errorf("Problem reading file %s", *file)
		}
		if err = json.Unmarshal(buf, &t.Data); err != nil {
			return fmt.Errorf("Problem parsing file %s", *file)
		}
	}

	// Use arguments as filepaths.
	t.Paths = flg.Args()

	return nil

}

// Compile compiles and generates the template files.
func (t *Tmpl) Compile() (err error) {

	// Verify we have at least one path.
	if len(t.Paths) == 0 {
		return errors.New("Provide a file path.")
	}

	// Process and compile each path.
	for _, path := range t.Paths {
		if err = t.compile(path); err != nil {
			return err
		}
	}

	return nil

}

func (t *Tmpl) compile(path string) error {

	// Validate that we have a prefix we can strip off for the generated path.
	if !strings.HasSuffix(path, Extension) {
		return fmt.Errorf("File %s must have extension %s extension", path, Extension)
	}

	file := strings.TrimSuffix(path, Extension)

	// Stat the file to retrieve the mode.
	fil, err := os.Stat(path)
	if os.IsNotExist(err) {
		return fmt.Errorf("File %s not found", path)
	} else if err != nil {
		return fmt.Errorf("Problem 1 %s", err)
		return err
	}

	// Read in template file.
	src, err := ioutil.ReadFile(path)
	if os.IsNotExist(err) {
		return fmt.Errorf("File %s not found", path)
	} else if err != nil {
		return fmt.Errorf("Problem 2 %s", err)
		return err
	}

	// Parse file into template.
	tpl, err := template.New("main").Funcs(FuncMap).Parse(string(src))
	if err != nil {
		return err
	}

	// Comment the generated code.
	var buf bytes.Buffer
	switch filepath.Ext(file) {
	case ".go":
		fmt.Fprintln(&buf, "// Code generated by https://github.com/abcum/tmpl")
		fmt.Fprintln(&buf, "// Source file:", path)
		fmt.Fprintln(&buf, "// DO NOT EDIT!")
		fmt.Fprintln(&buf, "")
	}

	// Execute the template.
	if err := tpl.Execute(&buf, t.Data); err != nil {
		return err
	}

	// Get the generated code.
	output := buf.Bytes()

	// Format any golang code.
	switch filepath.Ext(file) {
	case ".go":
		formatted, err := format.Source(output)
		if err != nil {
			return err
		}
		output = formatted
	}

	// Write buffer to file.
	if err := ioutil.WriteFile(file, output, fil.Mode()); err != nil {
		return err
	}

	return nil

}

var FuncMap = template.FuncMap{
	"upcase":   strings.ToUpper,
	"downcase": strings.ToLower,
	"camel":    camelCase,
}

func camelCase(s string) string {
	if s == "" {
		return s
	}
	return strings.ToLower(string(s[0])) + s[1:]
}
